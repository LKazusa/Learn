# HOOK
为了解决函数组件的功能不足的问题
本质上是一个函数，该函数用于增强函数组件的功能，命名上总是以use开头，该函数可以挂载任何功能
## State Hook
在函数组件中使用的函数(useState),用于在函数组件中使用状态 
- 函数有一个参数，表示状态的默认值
- 返回值为一个数组,第一项为状态的值,第二项为改变状态的函数(此函数的参数为新的状态值)
一个函数组件可以有多个状态，此做法非常有利于横向切分关注点
不同的函数组件不共用state，相当于每一个表格都挂在函数节点上
```js
import React, { useState } from 'react'
function Test(){
    let [n,setN] = useState(0);
    return <div>
        <button onClick={ ()=>setN(n-1) }> - </button>
            {n}
        <button onClick={ ()=>setN{n+1} }> + </button>
    </div>
}
```
实现：
    当运行一个组件调用该函数时，是React节点来调用此函数
    运行函数的时候useState,会检查该节点的状态表格，若是状态表格无内容，则会使用默认值创建状态，并加入到状态表格中
    第n次调用useState，会检查表格中是否有下标为n的值，不存在的话就使用默认值，并加到状态表格
    存在的时候。忽略掉默认值，直接返回状态值
注意：
1. useState最好写到函数的起始位置，便于阅读
2. useState严禁出现在判断循环中，即不能出现在代码块中
3. useState返回的函数引用不变，节约内存空间
4. 如果使用函数改变数据，若数据和之前的数据完全相等（Object.is）,则不会重新渲染
5. 在使用函数改变数据时，传入的值不会和原来的数据进行合并，直接替换(特别注意！！)，因此官方推荐使用小模块，或者使用扩展运算符
6. 如果要实现强制刷新组件
    - 类组件使用this.forceUpdate()  不会运行shouldComponentUpdate
    - 函数组件可以使用一个空对象的useState
    ```js
        const [, forceUpdate] = useState({});
        //使用
        forceUpdate({})
        //因为地址不同，强制刷新
    ```
7. 如果某些状态之间没有必然联系，应该分化为多个状态，不应为同一个对象。因为useState的出现是为了横切关注点
8. 和类组件状态一样，函数组件中改变状态在事件中时异步的，多个状态变化会合并以提高效率。所以此时不应该信任state，应使用回调函数
```js

    setN(prevN => prevN + 1);//函数在setN调用结束

```
